
bin/BareMetal.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000788  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  20000000  20000000  00001788  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  20000000  00000788  00002000  2**0
                  ALLOC
  3 Heap          00002dfc  20000004  00000788  00002004  2**0
                  ALLOC
  4 Stack         00000200  20002e00  00000788  00001e00  2**0
                  ALLOC
  5 .debug_info   00000a4a  00000000  00000000  00001788  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 000004d9  00000000  00000000  000021d2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_aranges 000000a0  00000000  00000000  000026ab  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   0000093e  00000000  00000000  0000274b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    00000476  00000000  00000000  00003089  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000044  00000000  00000000  000034ff  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002c  00000000  00000000  00003543  2**0
                  CONTENTS, READONLY
 12 .debug_frame  0000029c  00000000  00000000  00003570  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <vector>:
   0:	00 40 00 20 9b 06 00 00 31 07 00 00 39 07 00 00     .@. ....1...9...
	...
  2c:	31 07 00 00 00 00 00 00 00 00 00 00 31 07 00 00     1...........1...
  3c:	31 07 00 00 31 07 00 00 31 07 00 00 31 07 00 00     1...1...1...1...
  4c:	b5 01 00 00 31 07 00 00 31 07 00 00 31 07 00 00     ....1...1...1...
  5c:	31 07 00 00 31 07 00 00 31 07 00 00 31 07 00 00     1...1...1...1...
  6c:	31 07 00 00 31 07 00 00 31 07 00 00 31 07 00 00     1...1...1...1...
  7c:	31 07 00 00 31 07 00 00 31 07 00 00 31 07 00 00     1...1...1...1...
  8c:	31 07 00 00 31 07 00 00 31 07 00 00 31 07 00 00     1...1...1...1...
  9c:	31 07 00 00 31 07 00 00 31 07 00 00 31 07 00 00     1...1...1...1...
  ac:	31 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00     1...............
  bc:	00 00 00 00                                         ....

000000c0 <main>:
#define BTN_PIN 7



int main(void)
{
  c0:	b580      	push	{r7, lr}
  c2:	af00      	add	r7, sp, #0
    /*clock init*/
    clock_div16_init(0, 24, 8); //set clk_peri div16_0 for 24 Mhz divide by 24 and route to tcpwm2 clk (peripheral 8)
  c4:	2208      	movs	r2, #8
  c6:	2118      	movs	r1, #24
  c8:	2000      	movs	r0, #0
  ca:	f000 fa27 	bl	51c <clock_div16_init>

    /*timer init*/
    //*((uint32_t *)0xE000E410) = (1 << 30); //Timer 2 IRQn=19 Priority  1 set
    NVIC_EnableIRQ(19); //enable Timer 2 IRQn=20
  ce:	2013      	movs	r0, #19
  d0:	f000 faae 	bl	630 <NVIC_EnableIRQ>
    NVIC_SetPriority(19, 0); //set Timer 2 IRQn=19 Priority 
  d4:	2100      	movs	r1, #0
  d6:	2013      	movs	r0, #19
  d8:	f000 fa66 	bl	5a8 <NVIC_SetPriority>
    NVIC_ClearPendingIRQ(19); //clear any pending interrupt for Timer 2 in NVIC
  dc:	2013      	movs	r0, #19
  de:	f000 fa91 	bl	604 <NVIC_ClearPendingIRQ>
	
    /*TIMER 2 - INIT*/
    *((uint32_t *)0x40200000) &=~ (1<< 2); //Disable Timer 2  in TCPWM_CTRL Register
  e2:	4b2a      	ldr	r3, [pc, #168]	@ (18c <main+0xcc>)
  e4:	681a      	ldr	r2, [r3, #0]
  e6:	4b29      	ldr	r3, [pc, #164]	@ (18c <main+0xcc>)
  e8:	2104      	movs	r1, #4
  ea:	438a      	bics	r2, r1
  ec:	601a      	str	r2, [r3, #0]

    *((uint32_t *)0x40200188) = 0; //Clear the counter register of  TCPWM2 TCPWM_CNT2_COUNTER Register
  ee:	4b28      	ldr	r3, [pc, #160]	@ (190 <main+0xd0>)
  f0:	2200      	movs	r2, #0
  f2:	601a      	str	r2, [r3, #0]

    *((uint32_t *)0x402001A8) |= (0<<2); //Clear the  register of  TCPWM2 TCPWM_CNT2_TR_CTRL2 Register
  f4:	4a27      	ldr	r2, [pc, #156]	@ (194 <main+0xd4>)
  f6:	4b27      	ldr	r3, [pc, #156]	@ (194 <main+0xd4>)
  f8:	6812      	ldr	r2, [r2, #0]
  fa:	601a      	str	r2, [r3, #0]

	*((uint32_t *)0x40200194)  = (50000-1); //Set the Period Register of TCPWM2 TCPWM_CNT2_PERIOD Register
  fc:	4b26      	ldr	r3, [pc, #152]	@ (198 <main+0xd8>)
  fe:	4a27      	ldr	r2, [pc, #156]	@ (19c <main+0xdc>)
 100:	601a      	str	r2, [r3, #0]

	*((uint32_t *)0x40200180) |= (0 << 24); //Mode configuration of for TCPWM2, TCPWM_CNT2_CTRL Regsiter 
 102:	4a27      	ldr	r2, [pc, #156]	@ (1a0 <main+0xe0>)
 104:	4b26      	ldr	r3, [pc, #152]	@ (1a0 <main+0xe0>)
 106:	6812      	ldr	r2, [r2, #0]
 108:	601a      	str	r2, [r3, #0]

	*((uint32_t *)0x402001B8) |= (1 << 0); // Set  interrupt mask  by enabling the Interrupt in TCPWM_CNT2_INTR_MASK Register for TCPWM2
 10a:	4b26      	ldr	r3, [pc, #152]	@ (1a4 <main+0xe4>)
 10c:	681a      	ldr	r2, [r3, #0]
 10e:	4b25      	ldr	r3, [pc, #148]	@ (1a4 <main+0xe4>)
 110:	2101      	movs	r1, #1
 112:	430a      	orrs	r2, r1
 114:	601a      	str	r2, [r3, #0]

	*((uint32_t *)0x402001B0) = (1<<0); //Clear any previoius interrupt in  interrupt register in TCPWM_CNT2_INTR Register of TCPWM2 
 116:	4b24      	ldr	r3, [pc, #144]	@ (1a8 <main+0xe8>)
 118:	2201      	movs	r2, #1
 11a:	601a      	str	r2, [r3, #0]

    *((uint32_t *)0x40200000) |= (1<< 2); //Enable Timer 2  in TCPWM_CTRL Register
 11c:	4b1b      	ldr	r3, [pc, #108]	@ (18c <main+0xcc>)
 11e:	681a      	ldr	r2, [r3, #0]
 120:	4b1a      	ldr	r3, [pc, #104]	@ (18c <main+0xcc>)
 122:	2104      	movs	r1, #4
 124:	430a      	orrs	r2, r1
 126:	601a      	str	r2, [r3, #0]

    *((uint32_t *)0x40200008) |= (1 << 26); //Triger start Timer 2  in TCPWM_CTRL Register
 128:	4b20      	ldr	r3, [pc, #128]	@ (1ac <main+0xec>)
 12a:	681a      	ldr	r2, [r3, #0]
 12c:	4b1f      	ldr	r3, [pc, #124]	@ (1ac <main+0xec>)
 12e:	2180      	movs	r1, #128	@ 0x80
 130:	04c9      	lsls	r1, r1, #19
 132:	430a      	orrs	r2, r1
 134:	601a      	str	r2, [r3, #0]

    /*led init*/
    gpio_init(2,2, GPIO_OUTPUT_PUSH_PULL); //init p2.2 as output
 136:	2206      	movs	r2, #6
 138:	2102      	movs	r1, #2
 13a:	2002      	movs	r0, #2
 13c:	f000 f8cc 	bl	2d8 <gpio_init>

    gpio_init(2,0, GPIO_OUTPUT_PUSH_PULL); //init p2.0 as output
 140:	2206      	movs	r2, #6
 142:	2100      	movs	r1, #0
 144:	2002      	movs	r0, #2
 146:	f000 f8c7 	bl	2d8 <gpio_init>

    /*button*/
    gpio_init(3,7, GPIO_INPUT_PULLUP); //init p3.7 as input with pullup
 14a:	2202      	movs	r2, #2
 14c:	2107      	movs	r1, #7
 14e:	2003      	movs	r0, #3
 150:	f000 f8c2 	bl	2d8 <gpio_init>

    GPIO_PORT(3)->INTR_CFG |= (0x2 << (BTN_PIN * 2)); //set interrupt on falling edge for p3.7
 154:	4b16      	ldr	r3, [pc, #88]	@ (1b0 <main+0xf0>)
 156:	68da      	ldr	r2, [r3, #12]
 158:	4b15      	ldr	r3, [pc, #84]	@ (1b0 <main+0xf0>)
 15a:	2180      	movs	r1, #128	@ 0x80
 15c:	0209      	lsls	r1, r1, #8
 15e:	430a      	orrs	r2, r1
 160:	60da      	str	r2, [r3, #12]
    GPIO_PORT(3)->INTR |= (1 << BTN_PIN); //clear any pending interrupt for p3.7
 162:	4b13      	ldr	r3, [pc, #76]	@ (1b0 <main+0xf0>)
 164:	691a      	ldr	r2, [r3, #16]
 166:	4b12      	ldr	r3, [pc, #72]	@ (1b0 <main+0xf0>)
 168:	2180      	movs	r1, #128	@ 0x80
 16a:	430a      	orrs	r2, r1
 16c:	611a      	str	r2, [r3, #16]


    /*configuring interrupt*/
    

    NVIC_SetPriority(3, 1); //set highest priority for button
 16e:	2101      	movs	r1, #1
 170:	2003      	movs	r0, #3
 172:	f000 fa19 	bl	5a8 <NVIC_SetPriority>
    NVIC_EnableIRQ(3); //enable GPIO P3 interrupt in NVIC
 176:	2003      	movs	r0, #3
 178:	f000 fa5a 	bl	630 <NVIC_EnableIRQ>
    
    
    NVIC_ClearPendingIRQ(3); //clear any pending interrupt for GPIO P3 in NVIC
 17c:	2003      	movs	r0, #3
 17e:	f000 fa41 	bl	604 <NVIC_ClearPendingIRQ>

    enable_irq(); //enable global interrupts
 182:	f000 fa05 	bl	590 <enable_irq>

    while (1)
 186:	46c0      	nop			@ (mov r8, r8)
 188:	e7fd      	b.n	186 <main+0xc6>
 18a:	46c0      	nop			@ (mov r8, r8)
 18c:	40200000 	.word	0x40200000
 190:	40200188 	.word	0x40200188
 194:	402001a8 	.word	0x402001a8
 198:	40200194 	.word	0x40200194
 19c:	0000c34f 	.word	0x0000c34f
 1a0:	40200180 	.word	0x40200180
 1a4:	402001b8 	.word	0x402001b8
 1a8:	402001b0 	.word	0x402001b0
 1ac:	40200008 	.word	0x40200008
 1b0:	40040300 	.word	0x40040300

000001b4 <ioss_interrupts_gpio_3_IRQHandler>:
        
    }
}

void ioss_interrupts_gpio_3_IRQHandler(void)
{
 1b4:	b580      	push	{r7, lr}
 1b6:	af00      	add	r7, sp, #0
    //check if button is pressed
    GPIO_PORT(3)->INTR |= (1 << BTN_PIN); //clear interrupt
 1b8:	4b10      	ldr	r3, [pc, #64]	@ (1fc <ioss_interrupts_gpio_3_IRQHandler+0x48>)
 1ba:	691a      	ldr	r2, [r3, #16]
 1bc:	4b0f      	ldr	r3, [pc, #60]	@ (1fc <ioss_interrupts_gpio_3_IRQHandler+0x48>)
 1be:	2180      	movs	r1, #128	@ 0x80
 1c0:	430a      	orrs	r2, r1
 1c2:	611a      	str	r2, [r3, #16]
    
    if (gpio_read(3,7) == 0) //active low
 1c4:	2107      	movs	r1, #7
 1c6:	2003      	movs	r0, #3
 1c8:	f000 f98a 	bl	4e0 <gpio_read>
 1cc:	1e03      	subs	r3, r0, #0
 1ce:	d112      	bne.n	1f6 <ioss_interrupts_gpio_3_IRQHandler+0x42>
    {
        button_pressed ^= 1; //toggle button pressed state
 1d0:	4b0b      	ldr	r3, [pc, #44]	@ (200 <__HEAP_SIZE>)
 1d2:	781b      	ldrb	r3, [r3, #0]
 1d4:	b2db      	uxtb	r3, r3
 1d6:	2201      	movs	r2, #1
 1d8:	4053      	eors	r3, r2
 1da:	b2da      	uxtb	r2, r3
 1dc:	4b08      	ldr	r3, [pc, #32]	@ (200 <__HEAP_SIZE>)
 1de:	701a      	strb	r2, [r3, #0]
        gpio_write(2,0, !button_pressed); //toggle led at p2.0
 1e0:	4b07      	ldr	r3, [pc, #28]	@ (200 <__HEAP_SIZE>)
 1e2:	781b      	ldrb	r3, [r3, #0]
 1e4:	b2db      	uxtb	r3, r3
 1e6:	425a      	negs	r2, r3
 1e8:	4153      	adcs	r3, r2
 1ea:	b2db      	uxtb	r3, r3
 1ec:	001a      	movs	r2, r3
 1ee:	2100      	movs	r1, #0
 1f0:	2002      	movs	r0, #2
 1f2:	f000 f943 	bl	47c <gpio_write>
    }
}
 1f6:	46c0      	nop			@ (mov r8, r8)
 1f8:	46bd      	mov	sp, r7
 1fa:	bd80      	pop	{r7, pc}
 1fc:	40040300 	.word	0x40040300
 200:	20000000 	.word	0x20000000

00000204 <TIMER_2_IRQHandler>:

void TIMER_2_IRQHandler(void)
{
 204:	b580      	push	{r7, lr}
 206:	af00      	add	r7, sp, #0
    //check if timer expired
    if (*((uint32_t *)0x402001B0) & (1 << 0)) //check TC bit in TCPWM2 TCPWM_CNT2_INTR Register
 208:	4b0e      	ldr	r3, [pc, #56]	@ (244 <TIMER_2_IRQHandler+0x40>)
 20a:	681b      	ldr	r3, [r3, #0]
 20c:	2201      	movs	r2, #1
 20e:	4013      	ands	r3, r2
 210:	d015      	beq.n	23e <TIMER_2_IRQHandler+0x3a>
    {
        //clear interrupt
        *((uint32_t *)0x402001B0) |= (1 << 0); //clear TC bit in TCPWM2 TCPWM_CNT2_INTR Register
 212:	4b0c      	ldr	r3, [pc, #48]	@ (244 <TIMER_2_IRQHandler+0x40>)
 214:	681a      	ldr	r2, [r3, #0]
 216:	4b0b      	ldr	r3, [pc, #44]	@ (244 <TIMER_2_IRQHandler+0x40>)
 218:	2101      	movs	r1, #1
 21a:	430a      	orrs	r2, r1
 21c:	601a      	str	r2, [r3, #0]
        timer_flag ^= 1; //toggle timer flag
 21e:	4b0a      	ldr	r3, [pc, #40]	@ (248 <TIMER_2_IRQHandler+0x44>)
 220:	781b      	ldrb	r3, [r3, #0]
 222:	b2db      	uxtb	r3, r3
 224:	2201      	movs	r2, #1
 226:	4053      	eors	r3, r2
 228:	b2da      	uxtb	r2, r3
 22a:	4b07      	ldr	r3, [pc, #28]	@ (248 <TIMER_2_IRQHandler+0x44>)
 22c:	701a      	strb	r2, [r3, #0]
        gpio_write(2,2, timer_flag); //set p2.2 high
 22e:	4b06      	ldr	r3, [pc, #24]	@ (248 <TIMER_2_IRQHandler+0x44>)
 230:	781b      	ldrb	r3, [r3, #0]
 232:	b2db      	uxtb	r3, r3
 234:	001a      	movs	r2, r3
 236:	2102      	movs	r1, #2
 238:	2002      	movs	r0, #2
 23a:	f000 f91f 	bl	47c <gpio_write>

    }
}
 23e:	46c0      	nop			@ (mov r8, r8)
 240:	46bd      	mov	sp, r7
 242:	bd80      	pop	{r7, pc}
 244:	402001b0 	.word	0x402001b0
 248:	20000001 	.word	0x20000001

0000024c <hsiom_set>:

/* Each pin uses 4 bits in the HSIOM register */
#define HSIOM_BITS_PER_PIN     (4u)

void hsiom_set(uint8_t port, uint8_t pin, uint8_t function)
{
 24c:	b590      	push	{r4, r7, lr}
 24e:	b085      	sub	sp, #20
 250:	af00      	add	r7, sp, #0
 252:	0004      	movs	r4, r0
 254:	0008      	movs	r0, r1
 256:	0011      	movs	r1, r2
 258:	1dfb      	adds	r3, r7, #7
 25a:	1c22      	adds	r2, r4, #0
 25c:	701a      	strb	r2, [r3, #0]
 25e:	1dbb      	adds	r3, r7, #6
 260:	1c02      	adds	r2, r0, #0
 262:	701a      	strb	r2, [r3, #0]
 264:	1d7b      	adds	r3, r7, #5
 266:	1c0a      	adds	r2, r1, #0
 268:	701a      	strb	r2, [r3, #0]
    //hsiom configuring for gpio
    uint32_t hsiom_mask = (uint32_t)(0xFu << (pin * HSIOM_BITS_PER_PIN));
 26a:	1dbb      	adds	r3, r7, #6
 26c:	781b      	ldrb	r3, [r3, #0]
 26e:	009b      	lsls	r3, r3, #2
 270:	220f      	movs	r2, #15
 272:	409a      	lsls	r2, r3
 274:	0013      	movs	r3, r2
 276:	60fb      	str	r3, [r7, #12]
    uint32_t hsiom_val = (uint32_t)(function << (pin * HSIOM_BITS_PER_PIN));
 278:	1d7b      	adds	r3, r7, #5
 27a:	781a      	ldrb	r2, [r3, #0]
 27c:	1dbb      	adds	r3, r7, #6
 27e:	781b      	ldrb	r3, [r3, #0]
 280:	009b      	lsls	r3, r3, #2
 282:	409a      	lsls	r2, r3
 284:	0013      	movs	r3, r2
 286:	60bb      	str	r3, [r7, #8]

    HSIOM_PORT(port) &= ~hsiom_mask; //clear the hsiom mux for that pin
 288:	1dfb      	adds	r3, r7, #7
 28a:	781b      	ldrb	r3, [r3, #0]
 28c:	4a11      	ldr	r2, [pc, #68]	@ (2d4 <hsiom_set+0x88>)
 28e:	4694      	mov	ip, r2
 290:	4463      	add	r3, ip
 292:	021b      	lsls	r3, r3, #8
 294:	681a      	ldr	r2, [r3, #0]
 296:	68fb      	ldr	r3, [r7, #12]
 298:	43d9      	mvns	r1, r3
 29a:	1dfb      	adds	r3, r7, #7
 29c:	781b      	ldrb	r3, [r3, #0]
 29e:	480d      	ldr	r0, [pc, #52]	@ (2d4 <hsiom_set+0x88>)
 2a0:	4684      	mov	ip, r0
 2a2:	4463      	add	r3, ip
 2a4:	021b      	lsls	r3, r3, #8
 2a6:	400a      	ands	r2, r1
 2a8:	601a      	str	r2, [r3, #0]
    HSIOM_PORT(port) |= hsiom_val; //set the hsiom bits for gpio
 2aa:	1dfb      	adds	r3, r7, #7
 2ac:	781b      	ldrb	r3, [r3, #0]
 2ae:	4a09      	ldr	r2, [pc, #36]	@ (2d4 <hsiom_set+0x88>)
 2b0:	4694      	mov	ip, r2
 2b2:	4463      	add	r3, ip
 2b4:	021b      	lsls	r3, r3, #8
 2b6:	6819      	ldr	r1, [r3, #0]
 2b8:	1dfb      	adds	r3, r7, #7
 2ba:	781b      	ldrb	r3, [r3, #0]
 2bc:	4a05      	ldr	r2, [pc, #20]	@ (2d4 <hsiom_set+0x88>)
 2be:	4694      	mov	ip, r2
 2c0:	4463      	add	r3, ip
 2c2:	021b      	lsls	r3, r3, #8
 2c4:	68ba      	ldr	r2, [r7, #8]
 2c6:	430a      	orrs	r2, r1
 2c8:	601a      	str	r2, [r3, #0]
}
 2ca:	46c0      	nop			@ (mov r8, r8)
 2cc:	46bd      	mov	sp, r7
 2ce:	b005      	add	sp, #20
 2d0:	bd90      	pop	{r4, r7, pc}
 2d2:	46c0      	nop			@ (mov r8, r8)
 2d4:	00400200 	.word	0x00400200

000002d8 <gpio_init>:

void gpio_init(uint8_t port, uint8_t pin, gpio_dir_t dir){
 2d8:	b590      	push	{r4, r7, lr}
 2da:	b085      	sub	sp, #20
 2dc:	af00      	add	r7, sp, #0
 2de:	0004      	movs	r4, r0
 2e0:	0008      	movs	r0, r1
 2e2:	0011      	movs	r1, r2
 2e4:	1dfb      	adds	r3, r7, #7
 2e6:	1c22      	adds	r2, r4, #0
 2e8:	701a      	strb	r2, [r3, #0]
 2ea:	1dbb      	adds	r3, r7, #6
 2ec:	1c02      	adds	r2, r0, #0
 2ee:	701a      	strb	r2, [r3, #0]
 2f0:	1d7b      	adds	r3, r7, #5
 2f2:	1c0a      	adds	r2, r1, #0
 2f4:	701a      	strb	r2, [r3, #0]
    
    //configure drive mode in pc
    uint32_t pc_mask = (uint32_t)(0x7u<< (pin* GPIO_PC_BITS_PER_PIN));
 2f6:	1dbb      	adds	r3, r7, #6
 2f8:	781a      	ldrb	r2, [r3, #0]
 2fa:	0013      	movs	r3, r2
 2fc:	005b      	lsls	r3, r3, #1
 2fe:	189b      	adds	r3, r3, r2
 300:	2207      	movs	r2, #7
 302:	409a      	lsls	r2, r3
 304:	0013      	movs	r3, r2
 306:	60fb      	str	r3, [r7, #12]
    GPIO_PORT(port)->PC &= ~pc_mask;
 308:	1dfb      	adds	r3, r7, #7
 30a:	781b      	ldrb	r3, [r3, #0]
 30c:	4a5a      	ldr	r2, [pc, #360]	@ (478 <gpio_init+0x1a0>)
 30e:	4694      	mov	ip, r2
 310:	4463      	add	r3, ip
 312:	021b      	lsls	r3, r3, #8
 314:	689a      	ldr	r2, [r3, #8]
 316:	68fb      	ldr	r3, [r7, #12]
 318:	43d9      	mvns	r1, r3
 31a:	1dfb      	adds	r3, r7, #7
 31c:	781b      	ldrb	r3, [r3, #0]
 31e:	4856      	ldr	r0, [pc, #344]	@ (478 <gpio_init+0x1a0>)
 320:	4684      	mov	ip, r0
 322:	4463      	add	r3, ip
 324:	021b      	lsls	r3, r3, #8
 326:	400a      	ands	r2, r1
 328:	609a      	str	r2, [r3, #8]

    //setting drive mode
    if(dir==GPIO_OUTPUT_PUSH_PULL){
 32a:	1d7b      	adds	r3, r7, #5
 32c:	781b      	ldrb	r3, [r3, #0]
 32e:	2b06      	cmp	r3, #6
 330:	d122      	bne.n	378 <gpio_init+0xa0>
        GPIO_PORT(port)->PC |= (GPIO_DM_STRONG << (pin*GPIO_PC_BITS_PER_PIN));
 332:	1dfb      	adds	r3, r7, #7
 334:	781b      	ldrb	r3, [r3, #0]
 336:	4a50      	ldr	r2, [pc, #320]	@ (478 <gpio_init+0x1a0>)
 338:	4694      	mov	ip, r2
 33a:	4463      	add	r3, ip
 33c:	021b      	lsls	r3, r3, #8
 33e:	6899      	ldr	r1, [r3, #8]
 340:	1dbb      	adds	r3, r7, #6
 342:	781a      	ldrb	r2, [r3, #0]
 344:	0013      	movs	r3, r2
 346:	005b      	lsls	r3, r3, #1
 348:	189b      	adds	r3, r3, r2
 34a:	2206      	movs	r2, #6
 34c:	409a      	lsls	r2, r3
 34e:	1dfb      	adds	r3, r7, #7
 350:	781b      	ldrb	r3, [r3, #0]
 352:	4849      	ldr	r0, [pc, #292]	@ (478 <gpio_init+0x1a0>)
 354:	4684      	mov	ip, r0
 356:	4463      	add	r3, ip
 358:	021b      	lsls	r3, r3, #8
 35a:	430a      	orrs	r2, r1
 35c:	609a      	str	r2, [r3, #8]

        GPIO_PORT(port)->DR_SET = (1u<<pin);
 35e:	1dbb      	adds	r3, r7, #6
 360:	781a      	ldrb	r2, [r3, #0]
 362:	1dfb      	adds	r3, r7, #7
 364:	781b      	ldrb	r3, [r3, #0]
 366:	4944      	ldr	r1, [pc, #272]	@ (478 <gpio_init+0x1a0>)
 368:	468c      	mov	ip, r1
 36a:	4463      	add	r3, ip
 36c:	021b      	lsls	r3, r3, #8
 36e:	2101      	movs	r1, #1
 370:	4091      	lsls	r1, r2
 372:	000a      	movs	r2, r1
 374:	641a      	str	r2, [r3, #64]	@ 0x40
        GPIO_PORT(port)->PC |= (GPIO_DM_RES_DWN << (pin*GPIO_PC_BITS_PER_PIN));

        /* Enable pull-down by writing 0 to DR */
        GPIO_PORT(port)->DR_CLR = (1u << pin);
    }
}
 376:	e07b      	b.n	470 <gpio_init+0x198>
    else if(dir==GPIO_INPUT){
 378:	1d7b      	adds	r3, r7, #5
 37a:	781b      	ldrb	r3, [r3, #0]
 37c:	2b01      	cmp	r3, #1
 37e:	d116      	bne.n	3ae <gpio_init+0xd6>
        GPIO_PORT(port)->PC |= (GPIO_DM_HIGHZ << (pin*GPIO_PC_BITS_PER_PIN));
 380:	1dfb      	adds	r3, r7, #7
 382:	781b      	ldrb	r3, [r3, #0]
 384:	4a3c      	ldr	r2, [pc, #240]	@ (478 <gpio_init+0x1a0>)
 386:	4694      	mov	ip, r2
 388:	4463      	add	r3, ip
 38a:	021b      	lsls	r3, r3, #8
 38c:	6899      	ldr	r1, [r3, #8]
 38e:	1dbb      	adds	r3, r7, #6
 390:	781a      	ldrb	r2, [r3, #0]
 392:	0013      	movs	r3, r2
 394:	005b      	lsls	r3, r3, #1
 396:	189b      	adds	r3, r3, r2
 398:	2201      	movs	r2, #1
 39a:	409a      	lsls	r2, r3
 39c:	1dfb      	adds	r3, r7, #7
 39e:	781b      	ldrb	r3, [r3, #0]
 3a0:	4835      	ldr	r0, [pc, #212]	@ (478 <gpio_init+0x1a0>)
 3a2:	4684      	mov	ip, r0
 3a4:	4463      	add	r3, ip
 3a6:	021b      	lsls	r3, r3, #8
 3a8:	430a      	orrs	r2, r1
 3aa:	609a      	str	r2, [r3, #8]
}
 3ac:	e060      	b.n	470 <gpio_init+0x198>
    else if(dir==GPIO_INPUT_ANALOG){
 3ae:	1d7b      	adds	r3, r7, #5
 3b0:	781b      	ldrb	r3, [r3, #0]
 3b2:	2b00      	cmp	r3, #0
 3b4:	d10f      	bne.n	3d6 <gpio_init+0xfe>
        GPIO_PORT(port)->PC |= (GPIO_DM_ALG_HIZ << (pin*GPIO_PC_BITS_PER_PIN));
 3b6:	1dfb      	adds	r3, r7, #7
 3b8:	781b      	ldrb	r3, [r3, #0]
 3ba:	4a2f      	ldr	r2, [pc, #188]	@ (478 <gpio_init+0x1a0>)
 3bc:	4694      	mov	ip, r2
 3be:	4463      	add	r3, ip
 3c0:	021b      	lsls	r3, r3, #8
 3c2:	001a      	movs	r2, r3
 3c4:	1dfb      	adds	r3, r7, #7
 3c6:	781b      	ldrb	r3, [r3, #0]
 3c8:	492b      	ldr	r1, [pc, #172]	@ (478 <gpio_init+0x1a0>)
 3ca:	468c      	mov	ip, r1
 3cc:	4463      	add	r3, ip
 3ce:	021b      	lsls	r3, r3, #8
 3d0:	6892      	ldr	r2, [r2, #8]
 3d2:	609a      	str	r2, [r3, #8]
}
 3d4:	e04c      	b.n	470 <gpio_init+0x198>
    else if(dir==GPIO_INPUT_PULLUP){
 3d6:	1d7b      	adds	r3, r7, #5
 3d8:	781b      	ldrb	r3, [r3, #0]
 3da:	2b02      	cmp	r3, #2
 3dc:	d122      	bne.n	424 <gpio_init+0x14c>
        GPIO_PORT(port)->PC |= (GPIO_DM_RES_UP << (pin*GPIO_PC_BITS_PER_PIN));
 3de:	1dfb      	adds	r3, r7, #7
 3e0:	781b      	ldrb	r3, [r3, #0]
 3e2:	4a25      	ldr	r2, [pc, #148]	@ (478 <gpio_init+0x1a0>)
 3e4:	4694      	mov	ip, r2
 3e6:	4463      	add	r3, ip
 3e8:	021b      	lsls	r3, r3, #8
 3ea:	6899      	ldr	r1, [r3, #8]
 3ec:	1dbb      	adds	r3, r7, #6
 3ee:	781a      	ldrb	r2, [r3, #0]
 3f0:	0013      	movs	r3, r2
 3f2:	005b      	lsls	r3, r3, #1
 3f4:	189b      	adds	r3, r3, r2
 3f6:	2202      	movs	r2, #2
 3f8:	409a      	lsls	r2, r3
 3fa:	1dfb      	adds	r3, r7, #7
 3fc:	781b      	ldrb	r3, [r3, #0]
 3fe:	481e      	ldr	r0, [pc, #120]	@ (478 <gpio_init+0x1a0>)
 400:	4684      	mov	ip, r0
 402:	4463      	add	r3, ip
 404:	021b      	lsls	r3, r3, #8
 406:	430a      	orrs	r2, r1
 408:	609a      	str	r2, [r3, #8]
        GPIO_PORT(port)->DR_SET = (1u<<pin);
 40a:	1dbb      	adds	r3, r7, #6
 40c:	781a      	ldrb	r2, [r3, #0]
 40e:	1dfb      	adds	r3, r7, #7
 410:	781b      	ldrb	r3, [r3, #0]
 412:	4919      	ldr	r1, [pc, #100]	@ (478 <gpio_init+0x1a0>)
 414:	468c      	mov	ip, r1
 416:	4463      	add	r3, ip
 418:	021b      	lsls	r3, r3, #8
 41a:	2101      	movs	r1, #1
 41c:	4091      	lsls	r1, r2
 41e:	000a      	movs	r2, r1
 420:	641a      	str	r2, [r3, #64]	@ 0x40
}
 422:	e025      	b.n	470 <gpio_init+0x198>
    else if(dir==GPIO_INPUT_PULLDOWN){
 424:	1d7b      	adds	r3, r7, #5
 426:	781b      	ldrb	r3, [r3, #0]
 428:	2b03      	cmp	r3, #3
 42a:	d121      	bne.n	470 <gpio_init+0x198>
        GPIO_PORT(port)->PC |= (GPIO_DM_RES_DWN << (pin*GPIO_PC_BITS_PER_PIN));
 42c:	1dfb      	adds	r3, r7, #7
 42e:	781b      	ldrb	r3, [r3, #0]
 430:	4a11      	ldr	r2, [pc, #68]	@ (478 <gpio_init+0x1a0>)
 432:	4694      	mov	ip, r2
 434:	4463      	add	r3, ip
 436:	021b      	lsls	r3, r3, #8
 438:	6899      	ldr	r1, [r3, #8]
 43a:	1dbb      	adds	r3, r7, #6
 43c:	781a      	ldrb	r2, [r3, #0]
 43e:	0013      	movs	r3, r2
 440:	005b      	lsls	r3, r3, #1
 442:	189b      	adds	r3, r3, r2
 444:	2203      	movs	r2, #3
 446:	409a      	lsls	r2, r3
 448:	1dfb      	adds	r3, r7, #7
 44a:	781b      	ldrb	r3, [r3, #0]
 44c:	480a      	ldr	r0, [pc, #40]	@ (478 <gpio_init+0x1a0>)
 44e:	4684      	mov	ip, r0
 450:	4463      	add	r3, ip
 452:	021b      	lsls	r3, r3, #8
 454:	430a      	orrs	r2, r1
 456:	609a      	str	r2, [r3, #8]
        GPIO_PORT(port)->DR_CLR = (1u << pin);
 458:	1dbb      	adds	r3, r7, #6
 45a:	781a      	ldrb	r2, [r3, #0]
 45c:	1dfb      	adds	r3, r7, #7
 45e:	781b      	ldrb	r3, [r3, #0]
 460:	4905      	ldr	r1, [pc, #20]	@ (478 <gpio_init+0x1a0>)
 462:	468c      	mov	ip, r1
 464:	4463      	add	r3, ip
 466:	021b      	lsls	r3, r3, #8
 468:	2101      	movs	r1, #1
 46a:	4091      	lsls	r1, r2
 46c:	000a      	movs	r2, r1
 46e:	645a      	str	r2, [r3, #68]	@ 0x44
}
 470:	46c0      	nop			@ (mov r8, r8)
 472:	46bd      	mov	sp, r7
 474:	b005      	add	sp, #20
 476:	bd90      	pop	{r4, r7, pc}
 478:	00400400 	.word	0x00400400

0000047c <gpio_write>:

void gpio_write(uint8_t port, uint8_t pin, uint8_t value)
{
 47c:	b590      	push	{r4, r7, lr}
 47e:	b083      	sub	sp, #12
 480:	af00      	add	r7, sp, #0
 482:	0004      	movs	r4, r0
 484:	0008      	movs	r0, r1
 486:	0011      	movs	r1, r2
 488:	1dfb      	adds	r3, r7, #7
 48a:	1c22      	adds	r2, r4, #0
 48c:	701a      	strb	r2, [r3, #0]
 48e:	1dbb      	adds	r3, r7, #6
 490:	1c02      	adds	r2, r0, #0
 492:	701a      	strb	r2, [r3, #0]
 494:	1d7b      	adds	r3, r7, #5
 496:	1c0a      	adds	r2, r1, #0
 498:	701a      	strb	r2, [r3, #0]
    if (value)
 49a:	1d7b      	adds	r3, r7, #5
 49c:	781b      	ldrb	r3, [r3, #0]
 49e:	2b00      	cmp	r3, #0
 4a0:	d00c      	beq.n	4bc <gpio_write+0x40>
    {
        GPIO_PORT(port)->DR_SET = (1u << pin);
 4a2:	1dbb      	adds	r3, r7, #6
 4a4:	781a      	ldrb	r2, [r3, #0]
 4a6:	1dfb      	adds	r3, r7, #7
 4a8:	781b      	ldrb	r3, [r3, #0]
 4aa:	490c      	ldr	r1, [pc, #48]	@ (4dc <gpio_write+0x60>)
 4ac:	468c      	mov	ip, r1
 4ae:	4463      	add	r3, ip
 4b0:	021b      	lsls	r3, r3, #8
 4b2:	2101      	movs	r1, #1
 4b4:	4091      	lsls	r1, r2
 4b6:	000a      	movs	r2, r1
 4b8:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    else
    {
        GPIO_PORT(port)->DR_CLR = (1u << pin);
    }
}
 4ba:	e00b      	b.n	4d4 <gpio_write+0x58>
        GPIO_PORT(port)->DR_CLR = (1u << pin);
 4bc:	1dbb      	adds	r3, r7, #6
 4be:	781a      	ldrb	r2, [r3, #0]
 4c0:	1dfb      	adds	r3, r7, #7
 4c2:	781b      	ldrb	r3, [r3, #0]
 4c4:	4905      	ldr	r1, [pc, #20]	@ (4dc <gpio_write+0x60>)
 4c6:	468c      	mov	ip, r1
 4c8:	4463      	add	r3, ip
 4ca:	021b      	lsls	r3, r3, #8
 4cc:	2101      	movs	r1, #1
 4ce:	4091      	lsls	r1, r2
 4d0:	000a      	movs	r2, r1
 4d2:	645a      	str	r2, [r3, #68]	@ 0x44
}
 4d4:	46c0      	nop			@ (mov r8, r8)
 4d6:	46bd      	mov	sp, r7
 4d8:	b003      	add	sp, #12
 4da:	bd90      	pop	{r4, r7, pc}
 4dc:	00400400 	.word	0x00400400

000004e0 <gpio_read>:

uint8_t gpio_read(uint8_t port, uint8_t pin){
 4e0:	b580      	push	{r7, lr}
 4e2:	b082      	sub	sp, #8
 4e4:	af00      	add	r7, sp, #0
 4e6:	0002      	movs	r2, r0
 4e8:	1dfb      	adds	r3, r7, #7
 4ea:	701a      	strb	r2, [r3, #0]
 4ec:	1dbb      	adds	r3, r7, #6
 4ee:	1c0a      	adds	r2, r1, #0
 4f0:	701a      	strb	r2, [r3, #0]
    return (uint8_t)((GPIO_PORT(port)->PS >> pin) & 0x01u);
 4f2:	1dfb      	adds	r3, r7, #7
 4f4:	781b      	ldrb	r3, [r3, #0]
 4f6:	4a08      	ldr	r2, [pc, #32]	@ (518 <gpio_read+0x38>)
 4f8:	4694      	mov	ip, r2
 4fa:	4463      	add	r3, ip
 4fc:	021b      	lsls	r3, r3, #8
 4fe:	685a      	ldr	r2, [r3, #4]
 500:	1dbb      	adds	r3, r7, #6
 502:	781b      	ldrb	r3, [r3, #0]
 504:	40da      	lsrs	r2, r3
 506:	0013      	movs	r3, r2
 508:	b2db      	uxtb	r3, r3
 50a:	2201      	movs	r2, #1
 50c:	4013      	ands	r3, r2
 50e:	b2db      	uxtb	r3, r3
}
 510:	0018      	movs	r0, r3
 512:	46bd      	mov	sp, r7
 514:	b002      	add	sp, #8
 516:	bd80      	pop	{r7, pc}
 518:	00400400 	.word	0x00400400

0000051c <clock_div16_init>:
#include "clock.h"

void clock_div16_init(uint8_t divider_num, uint16_t divider_val, uint8_t peripheral)
{
 51c:	b590      	push	{r4, r7, lr}
 51e:	b083      	sub	sp, #12
 520:	af00      	add	r7, sp, #0
 522:	0004      	movs	r4, r0
 524:	0008      	movs	r0, r1
 526:	0011      	movs	r1, r2
 528:	1dfb      	adds	r3, r7, #7
 52a:	1c22      	adds	r2, r4, #0
 52c:	701a      	strb	r2, [r3, #0]
 52e:	1d3b      	adds	r3, r7, #4
 530:	1c02      	adds	r2, r0, #0
 532:	801a      	strh	r2, [r3, #0]
 534:	1dbb      	adds	r3, r7, #6
 536:	1c0a      	adds	r2, r1, #0
 538:	701a      	strb	r2, [r3, #0]
    /* Disable the divider before configuration */
    CLK_PERI_CMD = (1<<30)|(1<<6)|(1<<0);
 53a:	4b10      	ldr	r3, [pc, #64]	@ (57c <clock_div16_init+0x60>)
 53c:	4a10      	ldr	r2, [pc, #64]	@ (580 <clock_div16_init+0x64>)
 53e:	601a      	str	r2, [r3, #0]

    /* Set the division value */
    PERI_DIV_16_CTL(divider_num) = ((uint32_t)divider_val-1ul)<<8;
 540:	1d3b      	adds	r3, r7, #4
 542:	881b      	ldrh	r3, [r3, #0]
 544:	1e5a      	subs	r2, r3, #1
 546:	1dfb      	adds	r3, r7, #7
 548:	781b      	ldrb	r3, [r3, #0]
 54a:	490e      	ldr	r1, [pc, #56]	@ (584 <clock_div16_init+0x68>)
 54c:	468c      	mov	ip, r1
 54e:	4463      	add	r3, ip
 550:	009b      	lsls	r3, r3, #2
 552:	0212      	lsls	r2, r2, #8
 554:	601a      	str	r2, [r3, #0]

    /* Enable the divider */
    CLK_PERI_CMD = (1<<31) |(3<<14) |(63<<8) |(1<<6)|(1<<0);
 556:	4b09      	ldr	r3, [pc, #36]	@ (57c <clock_div16_init+0x60>)
 558:	4a0b      	ldr	r2, [pc, #44]	@ (588 <clock_div16_init+0x6c>)
 55a:	601a      	str	r2, [r3, #0]

    /*route to peripharal*/
    PERI_PCLK_CTL(peripheral) = (1<<6)|(divider_num<<0);
 55c:	1dfb      	adds	r3, r7, #7
 55e:	781b      	ldrb	r3, [r3, #0]
 560:	2240      	movs	r2, #64	@ 0x40
 562:	4313      	orrs	r3, r2
 564:	b2da      	uxtb	r2, r3
 566:	1dbb      	adds	r3, r7, #6
 568:	781b      	ldrb	r3, [r3, #0]
 56a:	4908      	ldr	r1, [pc, #32]	@ (58c <clock_div16_init+0x70>)
 56c:	468c      	mov	ip, r1
 56e:	4463      	add	r3, ip
 570:	009b      	lsls	r3, r3, #2
 572:	601a      	str	r2, [r3, #0]

 574:	46c0      	nop			@ (mov r8, r8)
 576:	46bd      	mov	sp, r7
 578:	b003      	add	sp, #12
 57a:	bd90      	pop	{r4, r7, pc}
 57c:	40010000 	.word	0x40010000
 580:	40000041 	.word	0x40000041
 584:	100040c0 	.word	0x100040c0
 588:	8000ff41 	.word	0x8000ff41
 58c:	10004040 	.word	0x10004040

00000590 <enable_irq>:
#include "cmsis_gcc.h"
#include <stdint.h>

void enable_irq(void)
{
 590:	b580      	push	{r7, lr}
 592:	af00      	add	r7, sp, #0
  __asm volatile ("cpsie i" : : : "memory");
 594:	b662      	cpsie	i
}
 596:	46c0      	nop			@ (mov r8, r8)
 598:	46bd      	mov	sp, r7
 59a:	bd80      	pop	{r7, pc}

0000059c <disable_irq>:

void disable_irq(void)
{
 59c:	b580      	push	{r7, lr}
 59e:	af00      	add	r7, sp, #0
  __asm volatile ("cpsid i" : : : "memory");
 5a0:	b672      	cpsid	i
}
 5a2:	46c0      	nop			@ (mov r8, r8)
 5a4:	46bd      	mov	sp, r7
 5a6:	bd80      	pop	{r7, pc}

000005a8 <NVIC_SetPriority>:

void NVIC_SetPriority(uint32_t IRQn, uint32_t priority)
{
 5a8:	b580      	push	{r7, lr}
 5aa:	b082      	sub	sp, #8
 5ac:	af00      	add	r7, sp, #0
 5ae:	6078      	str	r0, [r7, #4]
 5b0:	6039      	str	r1, [r7, #0]
  if ((int32_t)(IRQn) >= 0)
 5b2:	687b      	ldr	r3, [r7, #4]
 5b4:	2b00      	cmp	r3, #0
 5b6:	db1f      	blt.n	5f8 <NVIC_SetPriority+0x50>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 5b8:	4a11      	ldr	r2, [pc, #68]	@ (600 <NVIC_SetPriority+0x58>)
 5ba:	687b      	ldr	r3, [r7, #4]
 5bc:	089b      	lsrs	r3, r3, #2
 5be:	33c0      	adds	r3, #192	@ 0xc0
 5c0:	009b      	lsls	r3, r3, #2
 5c2:	589b      	ldr	r3, [r3, r2]
 5c4:	687a      	ldr	r2, [r7, #4]
 5c6:	2103      	movs	r1, #3
 5c8:	400a      	ands	r2, r1
 5ca:	00d2      	lsls	r2, r2, #3
 5cc:	21ff      	movs	r1, #255	@ 0xff
 5ce:	4091      	lsls	r1, r2
 5d0:	000a      	movs	r2, r1
 5d2:	43d2      	mvns	r2, r2
 5d4:	401a      	ands	r2, r3
 5d6:	0011      	movs	r1, r2
       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 5d8:	683b      	ldr	r3, [r7, #0]
 5da:	019b      	lsls	r3, r3, #6
 5dc:	22ff      	movs	r2, #255	@ 0xff
 5de:	401a      	ands	r2, r3
 5e0:	687b      	ldr	r3, [r7, #4]
 5e2:	2003      	movs	r0, #3
 5e4:	4003      	ands	r3, r0
 5e6:	00db      	lsls	r3, r3, #3
 5e8:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 5ea:	4805      	ldr	r0, [pc, #20]	@ (600 <NVIC_SetPriority+0x58>)
 5ec:	687b      	ldr	r3, [r7, #4]
 5ee:	089b      	lsrs	r3, r3, #2
 5f0:	430a      	orrs	r2, r1
 5f2:	33c0      	adds	r3, #192	@ 0xc0
 5f4:	009b      	lsls	r3, r3, #2
 5f6:	501a      	str	r2, [r3, r0]
  }

}
 5f8:	46c0      	nop			@ (mov r8, r8)
 5fa:	46bd      	mov	sp, r7
 5fc:	b002      	add	sp, #8
 5fe:	bd80      	pop	{r7, pc}
 600:	e000e100 	.word	0xe000e100

00000604 <NVIC_ClearPendingIRQ>:

void NVIC_ClearPendingIRQ(uint32_t IRQn)
{
 604:	b580      	push	{r7, lr}
 606:	b082      	sub	sp, #8
 608:	af00      	add	r7, sp, #0
 60a:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 60c:	687b      	ldr	r3, [r7, #4]
 60e:	2b00      	cmp	r3, #0
 610:	db08      	blt.n	624 <NVIC_ClearPendingIRQ+0x20>
  {
    NVIC->ICPR = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 612:	687b      	ldr	r3, [r7, #4]
 614:	221f      	movs	r2, #31
 616:	4013      	ands	r3, r2
 618:	4904      	ldr	r1, [pc, #16]	@ (62c <NVIC_ClearPendingIRQ+0x28>)
 61a:	2201      	movs	r2, #1
 61c:	409a      	lsls	r2, r3
 61e:	23c0      	movs	r3, #192	@ 0xc0
 620:	005b      	lsls	r3, r3, #1
 622:	50ca      	str	r2, [r1, r3]
  }
}
 624:	46c0      	nop			@ (mov r8, r8)
 626:	46bd      	mov	sp, r7
 628:	b002      	add	sp, #8
 62a:	bd80      	pop	{r7, pc}
 62c:	e000e100 	.word	0xe000e100

00000630 <NVIC_EnableIRQ>:

void NVIC_EnableIRQ(uint32_t IRQn)
{
 630:	b580      	push	{r7, lr}
 632:	b082      	sub	sp, #8
 634:	af00      	add	r7, sp, #0
 636:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 638:	687b      	ldr	r3, [r7, #4]
 63a:	2b00      	cmp	r3, #0
 63c:	db07      	blt.n	64e <NVIC_EnableIRQ+0x1e>
  {
    __asm volatile("":::"memory");
    NVIC->ISER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 63e:	687b      	ldr	r3, [r7, #4]
 640:	221f      	movs	r2, #31
 642:	401a      	ands	r2, r3
 644:	4b04      	ldr	r3, [pc, #16]	@ (658 <NVIC_EnableIRQ+0x28>)
 646:	2101      	movs	r1, #1
 648:	4091      	lsls	r1, r2
 64a:	000a      	movs	r2, r1
 64c:	601a      	str	r2, [r3, #0]
    __asm volatile("":::"memory");
  }
}
 64e:	46c0      	nop			@ (mov r8, r8)
 650:	46bd      	mov	sp, r7
 652:	b002      	add	sp, #8
 654:	bd80      	pop	{r7, pc}
 656:	46c0      	nop			@ (mov r8, r8)
 658:	e000e100 	.word	0xe000e100

0000065c <NVIC_DisableIRQ>:

void NVIC_DisableIRQ(uint32_t IRQn)
{
 65c:	b580      	push	{r7, lr}
 65e:	b082      	sub	sp, #8
 660:	af00      	add	r7, sp, #0
 662:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 664:	687b      	ldr	r3, [r7, #4]
 666:	2b00      	cmp	r3, #0
 668:	db0c      	blt.n	684 <NVIC_DisableIRQ+0x28>
  {
    NVIC->ICER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 66a:	687b      	ldr	r3, [r7, #4]
 66c:	221f      	movs	r2, #31
 66e:	4013      	ands	r3, r2
 670:	4906      	ldr	r1, [pc, #24]	@ (68c <NVIC_DisableIRQ+0x30>)
 672:	2201      	movs	r2, #1
 674:	409a      	lsls	r2, r3
 676:	0013      	movs	r3, r2
 678:	2280      	movs	r2, #128	@ 0x80
 67a:	508b      	str	r3, [r1, r2]
    __asm volatile ("dsb 0xF":::"memory");
 67c:	f3bf 8f4f 	dsb	sy
    __asm volatile ("isb 0xF":::"memory");
 680:	f3bf 8f6f 	isb	sy
  }
 684:	46c0      	nop			@ (mov r8, r8)
 686:	46bd      	mov	sp, r7
 688:	b002      	add	sp, #8
 68a:	bd80      	pop	{r7, pc}
 68c:	e000e100 	.word	0xe000e100

00000690 <_init>:
extern uint32_t __bss_start__;
extern uint32_t __bss_end__;

extern uint32_t __STACK_START;
extern uint32_t __STACK_END;
extern void _init(void) {;}
 690:	b580      	push	{r7, lr}
 692:	af00      	add	r7, sp, #0
 694:	46c0      	nop			@ (mov r8, r8)
 696:	46bd      	mov	sp, r7
 698:	bd80      	pop	{r7, pc}

0000069a <Reset_handler>:
    (uint32_t)can_interrupt_can_IRQHandler,             /*  26 CAN Interrupt */
    (uint32_t)crypto_interrupt_IRQHandler               /*  27 Crypto Interrupt */
};

void Reset_handler(void)
{
 69a:	b580      	push	{r7, lr}
 69c:	b086      	sub	sp, #24
 69e:	af00      	add	r7, sp, #0
    //disable watchdog
    (*(uint32_t *) CYREG_WDT_DISABLE_KEY) = CY_SYS_WDT_KEY;
 6a0:	4b1c      	ldr	r3, [pc, #112]	@ (714 <Reset_handler+0x7a>)
 6a2:	4a1d      	ldr	r2, [pc, #116]	@ (718 <Reset_handler+0x7e>)
 6a4:	601a      	str	r2, [r3, #0]

    //copy .data section to SRAM
    uint32_t size = &__data_end - &__data_start;
 6a6:	4a1d      	ldr	r2, [pc, #116]	@ (71c <Reset_handler+0x82>)
 6a8:	4b1d      	ldr	r3, [pc, #116]	@ (720 <Reset_handler+0x86>)
 6aa:	1ad3      	subs	r3, r2, r3
 6ac:	109b      	asrs	r3, r3, #2
 6ae:	607b      	str	r3, [r7, #4]
    uint32_t *pDst = (uint32_t*)&__data_start;
 6b0:	4b1b      	ldr	r3, [pc, #108]	@ (720 <Reset_handler+0x86>)
 6b2:	617b      	str	r3, [r7, #20]
    uint32_t *pSrc = (uint32_t*)&_la_data;
 6b4:	4b1b      	ldr	r3, [pc, #108]	@ (724 <Reset_handler+0x8a>)
 6b6:	613b      	str	r3, [r7, #16]

    for(uint32_t i = 0; i< size; i++)
 6b8:	2300      	movs	r3, #0
 6ba:	60fb      	str	r3, [r7, #12]
 6bc:	e00a      	b.n	6d4 <Reset_handler+0x3a>
    {
        *pDst++ = *pSrc++;
 6be:	693a      	ldr	r2, [r7, #16]
 6c0:	1d13      	adds	r3, r2, #4
 6c2:	613b      	str	r3, [r7, #16]
 6c4:	697b      	ldr	r3, [r7, #20]
 6c6:	1d19      	adds	r1, r3, #4
 6c8:	6179      	str	r1, [r7, #20]
 6ca:	6812      	ldr	r2, [r2, #0]
 6cc:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 6ce:	68fb      	ldr	r3, [r7, #12]
 6d0:	3301      	adds	r3, #1
 6d2:	60fb      	str	r3, [r7, #12]
 6d4:	68fa      	ldr	r2, [r7, #12]
 6d6:	687b      	ldr	r3, [r7, #4]
 6d8:	429a      	cmp	r2, r3
 6da:	d3f0      	bcc.n	6be <Reset_handler+0x24>
    }
    //int the .bss section to zero in SRAM
    size = &__bss_end__ - &__bss_start__;
 6dc:	4a12      	ldr	r2, [pc, #72]	@ (728 <Reset_handler+0x8e>)
 6de:	4b13      	ldr	r3, [pc, #76]	@ (72c <Reset_handler+0x92>)
 6e0:	1ad3      	subs	r3, r2, r3
 6e2:	109b      	asrs	r3, r3, #2
 6e4:	607b      	str	r3, [r7, #4]
    pDst = (uint32_t*)&__bss_start__;
 6e6:	4b11      	ldr	r3, [pc, #68]	@ (72c <Reset_handler+0x92>)
 6e8:	617b      	str	r3, [r7, #20]

    for(uint32_t i = 0; i< size; i++)
 6ea:	2300      	movs	r3, #0
 6ec:	60bb      	str	r3, [r7, #8]
 6ee:	e007      	b.n	700 <Reset_handler+0x66>
    {
        *pDst++ = 0;
 6f0:	697b      	ldr	r3, [r7, #20]
 6f2:	1d1a      	adds	r2, r3, #4
 6f4:	617a      	str	r2, [r7, #20]
 6f6:	2200      	movs	r2, #0
 6f8:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 6fa:	68bb      	ldr	r3, [r7, #8]
 6fc:	3301      	adds	r3, #1
 6fe:	60bb      	str	r3, [r7, #8]
 700:	68ba      	ldr	r2, [r7, #8]
 702:	687b      	ldr	r3, [r7, #4]
 704:	429a      	cmp	r2, r3
 706:	d3f3      	bcc.n	6f0 <Reset_handler+0x56>
    }

    // Init C std libs
    __libc_init_array();
 708:	f000 f81a 	bl	740 <__libc_init_array>
    

    //call main()
    main();
 70c:	f7ff fcd8 	bl	c0 <main>

    while (1)
 710:	46c0      	nop			@ (mov r8, r8)
 712:	e7fd      	b.n	710 <Reset_handler+0x76>
 714:	40030038 	.word	0x40030038
 718:	aced8865 	.word	0xaced8865
 71c:	20000000 	.word	0x20000000
 720:	20000000 	.word	0x20000000
 724:	00000788 	.word	0x00000788
 728:	20000004 	.word	0x20000004
 72c:	20000000 	.word	0x20000000

00000730 <Default_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Exceptions / Interrupts
 *----------------------------------------------------------------------------*/
void Default_Handler(void)
{
 730:	b580      	push	{r7, lr}
 732:	af00      	add	r7, sp, #0
    while(1);
 734:	46c0      	nop			@ (mov r8, r8)
 736:	e7fd      	b.n	734 <Default_Handler+0x4>

00000738 <HRDFLT_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Hard Fault
 *----------------------------------------------------------------------------*/
void HRDFLT_Handler(void)
{
 738:	b580      	push	{r7, lr}
 73a:	af00      	add	r7, sp, #0
    while(1);
 73c:	46c0      	nop			@ (mov r8, r8)
 73e:	e7fd      	b.n	73c <HRDFLT_Handler+0x4>

00000740 <__libc_init_array>:
 740:	b570      	push	{r4, r5, r6, lr}
 742:	2600      	movs	r6, #0
 744:	4c0c      	ldr	r4, [pc, #48]	@ (778 <__libc_init_array+0x38>)
 746:	4d0d      	ldr	r5, [pc, #52]	@ (77c <__libc_init_array+0x3c>)
 748:	1b64      	subs	r4, r4, r5
 74a:	10a4      	asrs	r4, r4, #2
 74c:	42a6      	cmp	r6, r4
 74e:	d109      	bne.n	764 <__libc_init_array+0x24>
 750:	2600      	movs	r6, #0
 752:	f7ff ff9d 	bl	690 <_init>
 756:	4c0a      	ldr	r4, [pc, #40]	@ (780 <__libc_init_array+0x40>)
 758:	4d0a      	ldr	r5, [pc, #40]	@ (784 <__libc_init_array+0x44>)
 75a:	1b64      	subs	r4, r4, r5
 75c:	10a4      	asrs	r4, r4, #2
 75e:	42a6      	cmp	r6, r4
 760:	d105      	bne.n	76e <__libc_init_array+0x2e>
 762:	bd70      	pop	{r4, r5, r6, pc}
 764:	00b3      	lsls	r3, r6, #2
 766:	58eb      	ldr	r3, [r5, r3]
 768:	4798      	blx	r3
 76a:	3601      	adds	r6, #1
 76c:	e7ee      	b.n	74c <__libc_init_array+0xc>
 76e:	00b3      	lsls	r3, r6, #2
 770:	58eb      	ldr	r3, [r5, r3]
 772:	4798      	blx	r3
 774:	3601      	adds	r6, #1
 776:	e7f2      	b.n	75e <__libc_init_array+0x1e>
	...
